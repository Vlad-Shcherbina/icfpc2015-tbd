#!/usr/bin/env python3

import argparse
import json
import itertools
import logging
import os
import pprint
import resource
import signal
import sys

from production import interfaces
from production import solver

logger = logging.getLogger(__name__)

NO_LIMIT = -1

parser = argparse.ArgumentParser()
# The parameter -f may be provided multiple times, which means that the program
# should produce results for all of the given inputs.
parser.add_argument('-f', action='append', default=[],
                    help='File containing JSON encoded input')
# If provided, the parameter -t indicates the execution time to produce the
# output for all problems. If it has not finished, the program will be killed
# after that many seconds. If -t is not provided, no time limit is imposed on
# the program.
parser.add_argument('-t', type=int, default=NO_LIMIT,
                    help='Time limit, in seconds, to produce output')
# If provided, the parameter -m indicates the maximum amount of memory that the
# program is allowed to use at any time. Programs that try to allocate more
# than this amount of memory will be killed. If -m is not provided, no memory
# limit (other than the hard memory limit of the system the judges choose to
# run it on) is imposed on the program.
parser.add_argument('-m', type=int, default=NO_LIMIT,
                    help='Memory limit, in megabytes, to produce output')
# If provided, the parameter -m indicates the maximum amount of memory that the
# program is allowed to use at any time. Programs that try to allocate more
# than this amount of memory will be killed. If -m is not provided, no memory
# limit (other than the hard memory limit of the system the judges choose to
# run it on) is imposed on the program.
parser.add_argument('-c', type=int, default=NO_LIMIT,
                    help='How many processor cores are available')
# Phrase of power, as quoted string - including the quotation marks. The
# parameter -p may be provided multiple times, once for each phrase of power
# the program should attempt to invoke in its output. As you discover more
# phrases of power, you can re-run the program with additional -p command line
# options; during judging (except for the lightning division), the program will
# be passed all the phrases of power.
parser.add_argument('-p', action='append', default=[],
                    help='Phrase of power, as quoted string')


# The output of the program should be a JSON list, containing one entry per
# problem and seed, using the following schema:
#
# [ { "problemId": number   /* The `id` of the game configuration */
#  , "seed":      number   /* The seed for the particular game */
#  , "tag":       string   /* A tag for this solution. */
#  , "solution":  Commands
#  }
# ]
#
# The tag field is meant to allow teams to associate scores on the leaderboards
# with specific submitted solutions. If no tag field is supplied, a tag will be
# generated from the submission time.


MEM_USAGE = 0

def update_memory_usage():
    pagesize = os.sysconf('SC_PAGE_SIZE')
    with open("/proc/%d/statm" % os.getpid()) as statm:
        # vms | rss | ... (sizes are in pages)
        global MEM_USAGE
        MEM_USAGE = int(statm.readline().split()[1]) * pagesize


def alarm_handler(*args):
    update_memory_usage()
    try:
        import humanize
        mem_usage = humanize.naturalsize(MEM_USAGE)
    except ImportError:
        mem_usage = '%.2fMb' % (MEM_USAGE / float(2 ** 20))
    logging.info('Current memory usage %s', mem_usage)
    signal.alarm(1)


def load_problems(path):
    problem_instances = []
    with open(path) as problem:
        logging.info('Loading %s', path)
        problem = json.load(problem)
        for seed in problem['sourceSeeds']:
            problem_instances.append(solver.ProblemInstance(problem, seed))
    return problem_instances


def prettify_limit(limit, fmt):
    return fmt % limit if limit != NO_LIMIT else 'no limit'


def main():
    logging.basicConfig(level=logging.DEBUG)
    args = parser.parse_args()

    problems = [load_problems(f) for f in args.f]
    problem_instances = list(itertools.chain.from_iterable(problems))
    power_phrases = [p for p in args.p]
    max_runtime = args.t
    max_memory = args.m
    cores_available = args.c

    logging.info(
        'Loaded %d problems (%d instances) and %d power phrases',
        len(problems), len(problem_instances), len(power_phrases))
    logging.info(
        'Time limit: %s, memory limit: %s, cores: %s',
        prettify_limit(max_runtime, '%ds'), 
        prettify_limit(max_memory, '%dMB'),
        prettify_limit(cores_available, '%d'))

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(1)

    with interfaces.with_custom_power_phrases(power_phrases):
        solutions = []
        for problem_instance in problem_instances:
            solutions.append(solver.solve(problem_instance))

    json.dump(solutions, sys.stdout)


if __name__ == '__main__':
    main()
